# 프로젝트 계획서: AI 멀티엔진 번역 라이브러리

## 1. 프로젝트 개요

### 1.1. 프로젝트명
AI 멀티엔진 번역 라이브러리

### 1.2. 목표
웹소설을 개인 서재에 추가하고, 작품별 용어사전을 적용하여 **여러 AI 번역 엔진(Gemini, Papago, DeepL)의 결과를 한눈에 비교**하고 최적의 번역문을 선택할 수 있는 고성능 웹 애플리케이션을 개발한다.

### 1.3. 핵심 기능
- **웹소설 검색 및 서재 관리**: 웹소설을 검색하여 개인 서재에 추가하고 관리한다.
- **목차 관리**: 작품별 시즌/챕터 목록을 체계적으로 보여준다.
- **다중 AI 번역 비교**: 선택한 챕터를 **Gemini, Papago, DeepL로 동시에 번역**하여 결과를 나란히 비교한다.
- **통합 용어사전**: 작품별로 설정한 용어사전을 **모든 번역 엔진에 일관되게 적용**하여 번역 품질을 통일한다.

---

## 2. 기술 스택 (Tools & Tech)

- **프로그래밍 언어**:
  - `Python`
- **핵심 API**:
  - `Google Gemini API`
  - `Naver Papago API`
  - `DeepL API`
- **주요 라이브러리 및 툴**:
  - **웹 프레임워크 (UI)**: `Streamlit`
  - **웹 크롤링**: `Requests` & `BeautifulSoup4`
  - **데이터베이스**: `SQLite`
  - **API 호출 라이브러리**:
    - `google-generativeai`
    - `requests`

---

## 3. 개발 계획 (Roadmap)

### Phase 1: 멀티엔진 코어 개발 (1-4주)
- **목표**: 단일 URL을 입력하면 3가지 번역 엔진의 결과를 모두 보여주는 비교 번역기 MVP를 완성한다.
- **주요 과업**:
  1. **API 키 통합 관리**: Gemini, Papago, DeepL의 API 키를 모두 발급받아 `.env` 파일에 안전하게 설정한다.
  2. **통합 번역 모듈 개발**:
     - `translate_gemini()`, `translate_papago()`, `translate_deepl()` 함수를 각각 구현한다.
     - 위 함수들을 모두 호출하여 `{'gemini': '...', 'papago': '...', 'deepl': '...'}` 형태의 딕셔너리로 결과를 반환하는 통합 함수를 만든다.
  3. **웹 크롤러 개발**: 단일 챕터의 본문을 추출하는 스크래퍼를 개발한다.
  4. **Streamlit 비교 UI 구현**:
     - URL 입력창과 "번역 비교" 버튼을 만든다.
     - `st.columns(3)`을 사용하여 3개의 번역 결과를 나란히 표시하는 UI를 제작한다.

### Phase 2: 라이브러리 기능 구현 (5-7주)
- **목표**: 작품 검색, 서재 추가, 목차 관리 기능을 구현하여 체계적인 라이브러리의 기틀을 마련한다.
- **주요 과업**:
  1. **데이터베이스 설계**: `novels`, `chapters` 테이블을 포함한 SQLite DB 스키마를 설계한다.
  2. **스크래퍼 고도화**: 작품 목록과 전체 목차를 수집할 수 있도록 기능을 확장한다.
  3. **UI 확장**: 작품 검색 페이지, 서재 목록 페이지, 작품별 챕터 목록 페이지를 구현한다.
  4. **기능 연동**: 챕터를 선택하면 Phase 1에서 만든 멀티엔진 번역기가 작동하도록 연동한다.

### Phase 3: 통합 용어사전 시스템 구축 (8-9주)
- **목표**: 작품별 용어사전이 모든 번역 엔진에 일관되게 적용되도록 시스템을 구축한다.
- **주요 과업**:
  1. **DB 확장**: 용어사전을 위한 `glossary` 테이블을 추가하고, 관리 UI를 개발한다.
  2. **용어사전 적용 로직 구현**:
     - **Gemini**: 번역 요청 시, 프롬프트에 용어사전 규칙을 동적으로 삽입한다.
     - **Papago & DeepL**: API 요청 전, 원문 텍스트에서 용어사전에 해당하는 단어를 미리 치환(`str.replace()`)하는 전처리 로직을 구현한다.
  3. **통합 테스트**: 모든 엔진에서 용어사전이 올바르게 적용되는지 종합적으로 테스트한다.

---

## 4. AI 어시스턴트 질문 가이드

### 일반 원칙
- **목표, 시도한 코드, 발생한 문제(에러 메시지)**를 함께 질문하여 구체성을 높인다.

### 디버깅 질문 형식
```
"아래 코드로 [목표]를 하려고 했는데,"

[여기에 본인 코드 붙여넣기]

"실행하니까 이런 에러가 발생했어."

[여기에 에러 메시지 전체 붙여넣기]

"이 에러의 원인이 뭐고, 어떻게 해결할 수 있을까?"
```


## 5. AI 활용 전략 및 심화 팁

이 프로젝트의 핵심은 AI, 특히 Gemini의 잠재력을 최대한 활용하는 것입니다. 아래 전략을 통해 단순 번역을 넘어 작품의 감성과 뉘앙스를 살리는 고품질 번역을 구현할 수 있습니다.

### 5.1. 페르소나(Persona) 부여 프롬프팅

Gemini API에 요청할 때, 번역 작업의 **역할과 정체성(페르소나)**을 명확하게 부여하면 결과물의 품질이 극적으로 향상됩니다.

- **기본 프롬프트**:
  > "다음 텍스트를 영어로 번역해줘."

- **고급 프롬프트 (페르소나 부여)**:
  > "You are a professional literary translator specializing in Korean fantasy web novels. Your goal is to create a translation that is not only accurate but also engaging and natural-sounding for an English-speaking audience. Maintain the original's tone, style, and emotional depth."
  > (당신은 한국 판타지 웹소설을 전문으로 다루는 문학 번역가입니다. 당신의 목표는 정확할 뿐만 아니라, 영어권 독자에게 매력적이고 자연스럽게 들리는 번역을 만드는 것입니다. 원작의 톤, 스타일, 감정의 깊이를 유지해 주세요.)

### 5.2. 컨텍스트(Context) 제공 및 체인 프롬프팅

긴 챕터를 한 번에 번역하면 일관성이 떨어질 수 있습니다. **중요한 컨텍스트를 요약**하여 매번 번역 요청 시 함께 제공하는 것이 효과적입니다.

- **구현 아이디어**:
  - **챕터 요약**: 이전 챕터의 핵심 사건이나 등장인물의 감정 상태를 몇 문장으로 요약합니다.
  - **인물 설정**: 현재 장면에 등장하는 인물들의 성격이나 관계를 간단히 명시합니다. (`Alex: a cynical knight, Maria: a cheerful mage`)
  - **프롬프트 구성**:
    ```python
    context = f"""
    - Previous Context: Alex just lost a battle and is feeling desperate.
    - Character Info: Alex is cynical, Maria is cheerful.
    - Glossary: '화룡검' must be 'Fire Dragon Sword'.
    """
    prompt = f"""
    {persona_prompt}

    Please translate the following text based on this context:
    {context}

    --- Korean Text ---
    {korean_text}
    """
    ```

### 5.3. 후처리(Post-processing)에 AI 재활용

Gemini의 강점은 번역뿐만 아니라 **윤문(Editing)**에도 있습니다. 1차 번역된 결과물을 다시 Gemini에 보내 더 자연스럽게 다듬도록 요청할 수 있습니다.

- **구현 아이디어**:
  1. Papago나 DeepL로 1차 초벌 번역을 수행합니다 (속도가 빠름).
  2. 초벌 번역된 영어 문장을 Gemini에 보내며 아래와 같이 요청합니다.
  > "You are a native English editor. The following text is a literal translation from Korean. Please revise it to make it sound more natural, fluid, and engaging, as if it were originally written in English."
  > (당신은 원어민 영어 편집자입니다. 다음은 한국어에서 직역된 텍스트입니다. 이 글을 원래 영어로 쓰인 것처럼 더 자연스럽고, 유려하며, 매력적으로 들리도록 수정해 주세요.)

### 5.4. 온도(Temperature) 파라미터 조절

Gemini API 호출 시 `temperature` 값을 조절하여 번역 결과의 창의성 수준을 제어할 수 있습니다.

- **`temperature=0.2` (낮은 값)**: 더 결정론적이고 일관된 번역. 직설적이고 정보 전달이 중요한 문장에 적합합니다.
- **`temperature=0.8` (높은 값)**: 더 창의적이고 다양한 표현. 문학적 비유나 감성적인 대사를 번역할 때 더 나은 결과를 낼 수 있습니다.

작품의 장르나 특정 장면의 분위기에 따라 이 값을 동적으로 조절하는 기능을 추가하면 번역 품질을 더욱 세밀하게 제어할 수 있습니다.

## 6. 단계별 AI 어시스턴트 질문 프롬프트 예시

이 섹션은 프로젝트의 각 단계에서 마주할 수 있는 문제 상황에 맞춰, AI 어시스턴트에게 바로 질문할 수 있는 프롬프트 템플릿입니다. `[ ]` 안에 자신의 상황에 맞는 내용을 채워서 질문하면 가장 효과적입니다.

### ### Phase 1: 멀티엔진 코어 개발 (1-4주)

#### ⚙️ **상황 1: 특정 API 연동 코드 요청**
> **목표**: 특정 번역 서비스의 API를 Python으로 호출하는 방법을 알고 싶을 때
>
> **프롬프트 템플릿**:
> ```
> 파이썬의 `requests` 라이브러리를 사용해서 **[API 이름, 예: DeepL API]**를 호출하는 코드 예시를 만들어줘.
>
> - **API 엔드포인트**: `[API 문서에 명시된 URL]`
> - **필요 헤더**: `[인증 키 등 필요한 헤더 정보]`
> - **요청 본문(Body)**: `[보내야 할 데이터 형식, 예: {'text': '번역할 문장', 'target_lang': 'EN'}]`
>
> 전체 코드를 하나의 함수로 만들어주고, API 키 같은 민감한 정보는 어떻게 안전하게 관리하는지도 알려줘.
> ```

#### 🐞 **상황 2: API 연동 중 에러 발생**
> **목표**: API 호출 코드가 예상대로 작동하지 않고 에러를 반환할 때
>
> **프롬프트 템플릿**:
> ```
> 아래 코드로 **[API 이름]** 번역을 테스트하고 있는데, 에러가 발생했어.
>
> **내 코드:**
> ```python
> [여기에 본인 코드 전체 붙여넣기]
> ```
>
> **발생한 에러:**
> ```
> [터미널에 출력된 에러 메시지 전체 붙여넣기]
> ```
>
> 이 에러의 원인이 뭘까? API 공식 문서를 참고해서 코드를 어떻게 수정해야 하는지 알려줘.
> ```

---

### ### Phase 2: 라이브러리 및 DB 기능 구현 (5-7주)

#### ⚙️ **상황 3: 데이터베이스 테이블 설계**
> **목표**: 프로젝트에 필요한 데이터베이스 구조에 대한 아이디어를 얻고 싶을 때
>
> **프롬프트 템플릿**:
> ```
> 웹소설 번역 라이브러리 프로젝트를 위해 SQLite 데이터베이스를 설계하고 있어. 아래 기능들을 구현하려면 어떤 테이블과 컬럼이 필요할까?
>
> **필수 기능:**
> - 작품 정보 저장 (제목, 작가, 표지 이미지 URL 등)
> - 작품별 챕터 목록 저장 (챕터 번호, 제목, URL 등)
>
> `novels` 테이블과 `chapters` 테이블의 `CREATE TABLE` SQL 구문을 작성해줘. 두 테이블을 어떻게 연결해야 하는지 (외래 키 설정) 포함해서 알려줘.
> ```

#### 🐞 **상황 4: 웹 크롤링이 안 될 때**
> **목표**: 특정 웹사이트의 HTML 구조가 복잡하여 원하는 정보를 추출하기 어려울 때
>
> **프롬프트 템플릿**:
> ```
> 파이썬 BeautifulSoup으로 웹소설 목차를 크롤링하려고 해. 목표는 각 챕터의 제목과 URL을 가져오는 거야.
>
> **대상 페이지 URL**: `[크롤링하려는 페이지 주소]`
>
> **페이지의 관련 HTML 구조:**
> ```html
> [브라우저 개발자 도구에서 복사한 HTML 일부 붙여넣기]
> ```
>
> 이 HTML 구조에서 모든 챕터의 제목(`a` 태그 안의 텍스트)과 `href` 속성값을 추출하는 파이썬 코드를 작성해줘. `find_all`과 `select` 중 어떤 걸 쓰는 게 더 효율적일까?
> ```

---

### ### Phase 3: 통합 용어사전 시스템 구축 (8-9주)

#### ⚙️ **상황 5: 복잡한 로직 구현 문의**
> **목표**: 여러 기능(DB, AI, UI)을 하나로 엮는 복잡한 로직을 구현해야 할 때
>
> **프롬프트 템플릿**:
> ```
> 내 Streamlit 앱에서 번역 기능을 구현하는 중이야. 사용자가 특정 작품의 특정 챕터를 번역 요청했을 때, 아래 순서대로 동작하는 파이썬 함수를 만들고 싶어.
>
> **동작 순서:**
> 1. 함수의 인자로 `novel_id`를 받는다.
> 2. SQLite DB의 `glossary` 테이블에 접속해서, 해당 `novel_id`를 가진 모든 용어(원문, 번역문)를 가져온다.
> 3. 가져온 용어들을 파이썬 딕셔너리 형태로 만든다.
> 4. 이 딕셔너리를 포함하는 Gemini API 용 프롬프트를 동적으로 생성해서 반환한다.
>
> 이 전체 과정을 처리하는 파이썬 함수 코드를 작성해줘.
> ```

#### 🐞 **상황 6: UI 상태 관리가 어려울 때**
> **목표**: Streamlit 앱에서 페이지를 이동하거나 버튼을 눌렀을 때 정보가 초기화되는 문제를 해결하고 싶을 때
>
> **프롬프트 템플릿**:
> ```
> Streamlit으로 다중 페이지 앱을 만들고 있어. '서재 페이지'에서 특정 작품을 클릭하면, `st.session_state`를 사용해서 선택된 작품의 `novel_id`를 '상세 페이지'로 넘겨주고 싶어.
>
> - '서재 페이지'에서 작품을 선택하고 `novel_id`를 `st.session_state`에 저장하는 방법
> - '상세 페이지'에서 저장된 `novel_id`를 안전하게 불러와서 사용하는 방법
>
> 이 두 페이지 간의 상태를 유지하는 간단한 코드 예시를 보여줘.
> ```